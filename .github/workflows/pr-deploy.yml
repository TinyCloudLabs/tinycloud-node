name: PR Preview Deploy

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  id-token: write
  contents: read
  pull-requests: write

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: tinycloud

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      image: ${{ steps.final-image.outputs.image }}
      build-skipped: ${{ steps.should-build.outputs.should-build != 'true' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check for Rust code changes
        id: check-changes
        uses: dorny/paths-filter@v2
        with:
          filters: |
            rust:
              - 'src/**'
              - 'Cargo.toml'
              - 'Cargo.lock' 
              - 'Dockerfile'
              - 'tinycloud-*/**'
              - 'siwe*/**'
              - 'cacao/**'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Create ECR repository if it doesn't exist
        run: |
          aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY }} || \
          aws ecr create-repository --repository-name ${{ env.ECR_REPOSITORY }} --image-scanning-configuration scanOnPush=true

      - name: Check if image already exists for this PR
        id: check-existing
        run: |
          PR_TAG="pr-${{ github.event.pull_request.number }}"
          if aws ecr describe-images --repository-name ${{ env.ECR_REPOSITORY }} --image-ids imageTag=$PR_TAG >/dev/null 2>&1; then
            echo "Image already exists for PR ${{ github.event.pull_request.number }}"
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "existing-image=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:$PR_TAG" >> $GITHUB_OUTPUT
          else
            echo "No existing image found for PR ${{ github.event.pull_request.number }}"
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Determine if we should build
        id: should-build
        run: |
          RUST_CHANGES="${{ steps.check-changes.outputs.rust }}"
          EXISTING_BUILD="${{ steps.check-existing.outputs.exists }}"
          
          # Build when: (Rust changes) OR (no existing build)
          if [ "$RUST_CHANGES" == "true" ] || [ "$EXISTING_BUILD" == "false" ]; then
            echo "should-build=true" >> $GITHUB_OUTPUT
            if [ "$RUST_CHANGES" == "true" ]; then
              echo "üî® Building because: Rust changes detected"
            else
              echo "üî® Building because: No existing build found"
            fi
          else
            echo "should-build=false" >> $GITHUB_OUTPUT
            echo "‚ôªÔ∏è Skipping build: No Rust changes and existing build found"
          fi

      - name: Set up Docker Buildx
        if: steps.should-build.outputs.should-build == 'true'
        uses: docker/setup-buildx-action@v3

      - name: Build and push Docker image
        if: steps.should-build.outputs.should-build == 'true'
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:pr-${{ github.event.pull_request.number }}
            ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:pr-${{ github.event.pull_request.number }}-${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64

      - name: Determine final image
        id: final-image
        run: |
          if [ "${{ steps.should-build.outputs.should-build }}" == "true" ]; then
            # We built a new image
            IMAGE="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:pr-${{ github.event.pull_request.number }}"
            echo "üî® Using newly built image"
          else
            # Use existing image
            IMAGE="${{ steps.check-existing.outputs.existing-image }}"
            echo "‚ôªÔ∏è Using existing image"
          fi
          
          echo "image=$IMAGE" >> $GITHUB_OUTPUT
          echo "Final image: $IMAGE"

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Bun
        uses: oven-sh/setup-bun@v1

      - name: Install dependencies
        run: bun install

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Generate unique secret for PR
        id: generate-secret
        run: |
          SECRET=$(openssl rand -base64 32)
          echo "::add-mask::$SECRET"
          echo "secret=$SECRET" >> $GITHUB_OUTPUT

      - name: Deploy to AWS
        id: deploy
        env:
          STAGE: pr-${{ github.event.pull_request.number }}
          TINYCLOUD_IMAGE: ${{ needs.build-and-push.outputs.image }}
        run: |
          # Set secrets for this PR stage
          npx sst secret set TINYCLOUD_KEYS_SECRET "${{ steps.generate-secret.outputs.secret }}" --stage $STAGE
          npx sst secret set AWS_ACCESS_KEY_ID "${{ secrets.TINYCLOUD_AWS_ACCESS_KEY_ID }}" --stage $STAGE
          npx sst secret set AWS_SECRET_ACCESS_KEY "${{ secrets.TINYCLOUD_AWS_SECRET_ACCESS_KEY }}" --stage $STAGE
          
          # Deploy with pre-built image
          npx sst deploy --stage $STAGE
          
          # Capture outputs
          SERVICE_URL=$(npx sst output --stage $STAGE --key serviceUrl)
          echo "url=$SERVICE_URL" >> $GITHUB_OUTPUT

      - name: Comment PR - Building
        if: needs.build-and-push.result == 'success'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const stage = `pr-${{ github.event.pull_request.number }}`;
            const identifier = `<!-- sst-deploy-${stage} -->`;
            
            const body = `${identifier}
            ## üî® Preview Deployment Building...
            
            **Environment:** \`${stage}\`
            **Status:** üü° Deploying infrastructure...
            
            ---
            
            > üí° This usually takes 3-5 minutes. This comment will update when deployment is complete.`;
            
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const existingComment = comments.find(c => c.body.includes(identifier));
            
            if (existingComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body
              });
            }

      - name: Comment PR - Success
        if: success()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const stage = `pr-${{ github.event.pull_request.number }}`;
            const url = '${{ steps.deploy.outputs.url }}';
            const runUrl = `${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}`;
            const image = '${{ needs.build-and-push.outputs.image }}';
            const buildSkipped = '${{ needs.build-and-push.outputs.build-skipped }}' === 'true';
            
            // Determine build status message
            let buildStatus = '';
            if (buildSkipped) {
              buildStatus = '‚ôªÔ∏è **Build:** Skipped (no Rust changes, reused existing image)';
            } else {
              buildStatus = 'üî® **Build:** New image built from Rust changes';
            }
            
            const identifier = `<!-- sst-deploy-${stage} -->`;
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const existingComment = comments.find(c => c.body.includes(identifier));
            
            const body = `${identifier}
            ## üöÄ Preview Deployment Ready!
            
            **Environment:** \`${stage}\`
            **URL:** ${url}
            **Status:** ‚úÖ Deployed successfully
            
            ${buildStatus}
            
            <details>
            <summary>Deployment Details</summary>
            
            - **Stage:** \`${stage}\`
            - **Region:** \`${env.AWS_REGION}\`
            - **Deploy Time:** ${new Date().toISOString()}
            - **Docker Image:** \`${image}\`
            - **Workflow Run:** [View Logs](${runUrl})
            - **Build Optimized:** ${buildSkipped ? 'Yes - reused existing build' : 'No - built new image'}
            
            </details>
            
            ---
            
            > üí° This is an isolated preview environment with its own database. It will be automatically cleaned up when the PR is closed.`;
            
            if (existingComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body
              });
            }

      - name: Comment PR - Failure
        if: failure()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const stage = `pr-${{ github.event.pull_request.number }}`;
            const runUrl = `${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}`;
            
            const identifier = `<!-- sst-deploy-${stage} -->`;
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const existingComment = comments.find(c => c.body.includes(identifier));
            
            const body = `${identifier}
            ## ‚ùå Preview Deployment Failed
            
            **Environment:** \`${stage}\`
            **Status:** Failed to deploy
            
            Please check the [workflow logs](${runUrl}) for more details.
            
            ---
            
            > üí° Once the issues are resolved, push a new commit to trigger a redeployment.`;
            
            if (existingComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body
              });
            }