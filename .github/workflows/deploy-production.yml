name: Production Deploy

on:
  push:
    branches: [main]
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: tinycloud

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    outputs:
      image: ${{ steps.image.outputs.image }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          toolchain: stable
          cache: true

      - name: Run tests
        run: cargo test

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Create ECR repository if it doesn't exist
        run: |
          aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY }} || \
          aws ecr create-repository --repository-name ${{ env.ECR_REPOSITORY }} --image-scanning-configuration scanOnPush=true

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:latest
            ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:main-${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64

      - name: Output image
        id: image
        run: |
          echo "image=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:main-${{ github.sha }}" >> $GITHUB_OUTPUT

  deploy:
    needs: build-and-test
    runs-on: ubuntu-latest
    environment: production
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Bun
        uses: oven-sh/setup-bun@v1

      - name: Install dependencies
        run: bun install

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy to Production
        id: deploy
        env:
          STAGE: production
          TINYCLOUD_IMAGE: ${{ needs.build-and-test.outputs.image }}
        run: |
          # Set production secrets (these should already exist)
          npx sst secret set TINYCLOUD_KEYS_SECRET "${{ secrets.PROD_TINYCLOUD_KEYS_SECRET }}" --stage $STAGE
          npx sst secret set AWS_ACCESS_KEY_ID "${{ secrets.PROD_TINYCLOUD_AWS_ACCESS_KEY_ID }}" --stage $STAGE
          npx sst secret set AWS_SECRET_ACCESS_KEY "${{ secrets.PROD_TINYCLOUD_AWS_SECRET_ACCESS_KEY }}" --stage $STAGE
          
          # Deploy with production stage and pre-built image
          npx sst deploy --stage $STAGE
          
          # Capture outputs
          SERVICE_URL=$(npx sst output --stage $STAGE --key serviceUrl)
          echo "url=$SERVICE_URL" >> $GITHUB_OUTPUT
          echo "Production URL: $SERVICE_URL"

      - name: Create deployment record
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              environment: 'production',
              required_contexts: [],
              auto_merge: false,
            });
            
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: deployment.data.id,
              state: 'success',
              environment_url: '${{ steps.deploy.outputs.url }}',
              description: 'Deployed to production',
            });

      - name: Configure ECR lifecycle policy
        run: |
          # Keep only the latest 10 production images
          cat <<EOF > lifecycle-policy.json
          {
            "rules": [
              {
                "rulePriority": 1,
                "description": "Keep last 10 production images",
                "selection": {
                  "tagStatus": "tagged",
                  "tagPrefixList": ["main-"],
                  "countType": "imageCountMoreThan",
                  "countNumber": 10
                },
                "action": {
                  "type": "expire"
                }
              },
              {
                "rulePriority": 2,
                "description": "Remove untagged images after 1 day",
                "selection": {
                  "tagStatus": "untagged",
                  "countType": "sinceImagePushed",
                  "countUnit": "days",
                  "countNumber": 1
                },
                "action": {
                  "type": "expire"
                }
              }
            ]
          }
          EOF
          
          aws ecr put-lifecycle-policy \
            --repository-name ${{ env.ECR_REPOSITORY }} \
            --lifecycle-policy-text file://lifecycle-policy.json