name: Manual GHCR Push

on:
  workflow_dispatch:
    inputs:
      use_ecr_image:
        description: 'ECR image tag to use (e.g., "latest" or "main-abc123")'
        required: false
        default: 'latest'
        type: string
      force_rebuild:
        description: 'Force rebuild from source instead of using ECR'
        required: false
        default: false
        type: boolean
      additional_tag:
        description: 'Additional custom tag (optional)'
        required: false
        type: string
      mark_as_latest:
        description: 'Update the "latest" tag'
        required: false
        default: false
        type: boolean
      dry_run:
        description: 'Test without pushing to GHCR'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: tinycloud
  GHCR_REPOSITORY: ghcr.io/tinycloudlabs/tinycloud-node
  PLATFORMS: linux/amd64

permissions:
  id-token: write
  contents: read
  packages: write

jobs:
  push-to-ghcr:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Install cosign
        uses: sigstore/cosign-installer@v3

      - name: Configure AWS credentials
        if: ${{ !inputs.force_rebuild }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        if: ${{ !inputs.force_rebuild }}
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate tags
        id: tags
        run: |
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          DATE=$(date +'%Y%m%d')
          MANUAL_TAG="manual-${DATE}-${SHORT_SHA}"

          TAGS="${GHCR_REPOSITORY}:${MANUAL_TAG}"
          TAGS="${TAGS},${GHCR_REPOSITORY}:latest-manual"

          if [ "${{ inputs.additional_tag }}" != "" ]; then
            TAGS="${TAGS},${GHCR_REPOSITORY}:${{ inputs.additional_tag }}"
          fi

          if [ "${{ inputs.mark_as_latest }}" == "true" ]; then
            TAGS="${TAGS},${GHCR_REPOSITORY}:latest"
          fi

          echo "tags=${TAGS}" >> $GITHUB_OUTPUT
          echo "manual_tag=${MANUAL_TAG}" >> $GITHUB_OUTPUT
          echo "Generated tags: ${TAGS}"

      - name: Check ECR image exists
        if: ${{ !inputs.force_rebuild }}
        id: ecr-check
        run: |
          ECR_IMAGE="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ inputs.use_ecr_image }}"

          if aws ecr describe-images --repository-name ${{ env.ECR_REPOSITORY }} --image-ids imageTag=${{ inputs.use_ecr_image }} 2>/dev/null; then
            echo "found=true" >> $GITHUB_OUTPUT
            echo "ecr_image=${ECR_IMAGE}" >> $GITHUB_OUTPUT
            echo "‚úÖ Found ECR image: ${ECR_IMAGE}"

            # Get image manifest for metadata
            docker pull ${ECR_IMAGE}
            IMAGE_SIZE=$(docker image inspect ${ECR_IMAGE} --format='{{.Size}}' | numfmt --to=iec)
            echo "Image size: ${IMAGE_SIZE}"
            echo "image_size=${IMAGE_SIZE}" >> $GITHUB_OUTPUT
          else
            echo "found=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è ECR image not found, will build from source"
          fi

      - name: Backup previous manual tag
        if: ${{ !inputs.dry_run }}
        continue-on-error: true
        run: |
          # Try to retag latest-manual as previous-manual for rollback
          docker pull ${GHCR_REPOSITORY}:latest-manual 2>/dev/null && \
          docker tag ${GHCR_REPOSITORY}:latest-manual ${GHCR_REPOSITORY}:previous-manual && \
          docker push ${GHCR_REPOSITORY}:previous-manual && \
          echo "‚úÖ Backed up previous manual image" || \
          echo "‚ö†Ô∏è No previous manual image to backup"

      - name: Transfer from ECR to GHCR
        if: ${{ !inputs.force_rebuild && steps.ecr-check.outputs.found == 'true' && !inputs.dry_run }}
        id: transfer
        run: |
          ECR_IMAGE="${{ steps.ecr-check.outputs.ecr_image }}"

          # Pull from ECR
          docker pull ${ECR_IMAGE} --platform=${PLATFORMS}

          # Tag for GHCR
          IFS=',' read -ra TAG_ARRAY <<< "${{ steps.tags.outputs.tags }}"
          for TAG in "${TAG_ARRAY[@]}"; do
            docker tag ${ECR_IMAGE} ${TAG}
            echo "Tagged: ${TAG}"
          done

          # Push to GHCR
          for TAG in "${TAG_ARRAY[@]}"; do
            docker push ${TAG}
            echo "Pushed: ${TAG}"
          done

          echo "method=transfer" >> $GITHUB_OUTPUT

      - name: Build and push from source
        if: ${{ inputs.force_rebuild || steps.ecr-check.outputs.found == 'false' }}
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: ${{ env.PLATFORMS }}
          push: ${{ !inputs.dry_run }}
          tags: ${{ steps.tags.outputs.tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          labels: |
            org.opencontainers.image.source=${{ github.event.repository.html_url }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created=${{ steps.tags.outputs.manual_tag }}
            org.opencontainers.image.authors=${{ github.actor }}
            org.opencontainers.image.description=Manual GHCR push from ${{ inputs.force_rebuild && 'source' || inputs.use_ecr_image }}

      - name: Run smoke test
        if: ${{ !inputs.dry_run }}
        run: |
          # Pull and test the newly pushed image
          docker pull ${GHCR_REPOSITORY}:${{ steps.tags.outputs.manual_tag }}

          # Basic smoke test - ensure container can start
          docker run -d --name smoke-test \
            -e TINYCLOUD_URL=http://localhost:3000 \
            -e TINYCLOUD_KEYS_SECRET=test \
            ${GHCR_REPOSITORY}:${{ steps.tags.outputs.manual_tag }}

          # Wait a moment for startup
          sleep 5

          # Check if container is still running
          if docker ps | grep smoke-test; then
            echo "‚úÖ Container smoke test passed"
            docker stop smoke-test
            docker rm smoke-test
          else
            echo "‚ùå Container failed to start"
            docker logs smoke-test
            docker rm smoke-test
            exit 1
          fi

      - name: Sign image with cosign
        if: ${{ !inputs.dry_run }}
        env:
          COSIGN_EXPERIMENTAL: 1
        run: |
          # Sign all pushed tags
          IFS=',' read -ra TAG_ARRAY <<< "${{ steps.tags.outputs.tags }}"
          for TAG in "${TAG_ARRAY[@]}"; do
            echo "Signing ${TAG}..."
            cosign sign --yes ${TAG}
          done

          echo "‚úÖ Images signed with cosign"

      - name: Scan image for vulnerabilities
        if: ${{ !inputs.dry_run }}
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.GHCR_REPOSITORY }}:${{ steps.tags.outputs.manual_tag }}
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'
          exit-code: '0'  # Don't fail on vulnerabilities, just report

      - name: Upload Trivy results
        if: ${{ !inputs.dry_run }}
        uses: github/codeql-action/upload-sarif@v3
        continue-on-error: true
        with:
          sarif_file: 'trivy-results.sarif'

      - name: Generate summary
        if: ${{ !inputs.dry_run }}
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## üì¶ GHCR Push Summary

          **Status:** ‚úÖ Success
          **Method:** ${{ inputs.force_rebuild && 'üî® Built from source' || '‚ôªÔ∏è Transferred from ECR' }}
          **Primary Tag:** \`${{ steps.tags.outputs.manual_tag }}\`

          ### Tags Pushed
          EOF

          IFS=',' read -ra TAG_ARRAY <<< "${{ steps.tags.outputs.tags }}"
          for TAG in "${TAG_ARRAY[@]}"; do
            echo "- \`${TAG}\`" >> $GITHUB_STEP_SUMMARY
          done

          cat >> $GITHUB_STEP_SUMMARY << EOF

          ### Details
          - **Trigger User:** @${{ github.actor }}
          - **Source Commit:** \`${{ github.sha }}\`
          - **Platform:** \`${PLATFORMS}\`
          - **Signed:** ‚úÖ Yes (keyless with cosign)
          EOF

          if [ "${{ steps.ecr-check.outputs.image_size }}" != "" ]; then
            echo "- **Image Size:** ${{ steps.ecr-check.outputs.image_size }}" >> $GITHUB_STEP_SUMMARY
          fi

          cat >> $GITHUB_STEP_SUMMARY << EOF

          ### Pull Command
          \`\`\`bash
          docker pull ${GHCR_REPOSITORY}:${{ steps.tags.outputs.manual_tag }}
          \`\`\`

          ### Verify Signature
          \`\`\`bash
          cosign verify ${GHCR_REPOSITORY}:${{ steps.tags.outputs.manual_tag }} \\
            --certificate-identity-regexp "https://github.com/${{ github.repository }}/*" \\
            --certificate-oidc-issuer https://token.actions.githubusercontent.com
          \`\`\`
          EOF

      - name: Dry run summary
        if: ${{ inputs.dry_run }}
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## üß™ GHCR Push (Dry Run)

          **Status:** ‚úÖ Dry run completed
          **Method:** ${{ inputs.force_rebuild && 'üî® Would build from source' || '‚ôªÔ∏è Would transfer from ECR' }}

          ### Tags that would be pushed:
          EOF

          IFS=',' read -ra TAG_ARRAY <<< "${{ steps.tags.outputs.tags }}"
          for TAG in "${TAG_ARRAY[@]}"; do
            echo "- \`${TAG}\`" >> $GITHUB_STEP_SUMMARY
          done

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚ÑπÔ∏è No images were pushed (dry run mode)" >> $GITHUB_STEP_SUMMARY

      - name: Cleanup old manual tags
        if: ${{ !inputs.dry_run }}
        continue-on-error: true
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # List all package versions with manual- prefix older than 30 days
          # and delete them to save storage

          CUTOFF_DATE=$(date -d '30 days ago' +%s)

          # Get package versions
          gh api \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "/orgs/tinycloudlabs/packages/container/tinycloud-node/versions?per_page=100" \
            --jq '.[] | select(.metadata.container.tags[] | startswith("manual-")) | select(.created_at | fromdateiso8601 < '$CUTOFF_DATE') | .id' | \
          while read -r VERSION_ID; do
            echo "Deleting old manual tag version: $VERSION_ID"
            gh api \
              --method DELETE \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "/orgs/tinycloudlabs/packages/container/tinycloud-node/versions/$VERSION_ID" || true
          done
